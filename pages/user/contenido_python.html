<!DOCTYPE html>
<html>
    <head>
        
        <title>
            Contenido
        </title>
        <link rel="stylesheet" href="./../../css/aaron.css">
        <link rel="stylesheet" href="./../../css/styles.css">
    </head>
    <body>
        <div id="encabezado">
            <ul>
                <li class="item-header" id="titulo">
                    <h2 onclick="window.location.href= './../welcome.html'" style="cursor: pointer;"> AlgoByte</h2>
                </li>
                <li class="item-header">
                    <nav>
                        <li class="item-nav">
                            <a href="./content.html">Contenido</a>
                        </li>
                        <li class="item-nav">
                            <a href="./quiz.html">Quiz</a>
                        </li>
                        <li class="item-nav">
                            <a href="./changeCareer.html">Cambiar Curso</a>
                        </li>
                        <li class="item-nav">
                            <a href="./changePassword.html">Cambiar Contraseña</a>
                        </li>
                        <li class="item-nav">
                            <a onclick="logout()">Cerrar Sesion</a>
                        </li> 
                    </nav>
                </li>
            </ul>
        </div>
        
        <main>
            <div class="contenido">
                <h2 class="tipos-contenido">Creacion de Variables y Constantes</h2>
                <p class="parrafo-contenido">Variables:<br><br>
                    •	Definición: Espacios en memoria para almacenar datos que pueden cambiar durante la ejecución del programa.<br><br>
                    •	Nomenclatura:<br>
                    o	Deben comenzar con una letra (a-z, A-Z) o un guion bajo (_).<br>
                    o	Pueden contener letras, números (0-9), y guiones bajos.<br>
                    o	No pueden usar palabras reservadas de Python (e.g., for, if, while).<br><br>
                    Sintaxis:<br><br>
                    
                    variable = valor<br>
                    Ejemplos:<br>
                    
                    nombre = "Juan"  # string<br>
                    edad = 25  # int<br>
                    altura = 1.75  # float<br>
                    es_estudiante = True  # boolean<br>
                    Buenas Prácticas:<br><br>
                    •	Usar nombres descriptivos para las variables:<br>
                    
                    contador = 10<br>
                    suma_total = 100.5<br>
                    nombre_completo = "Ana García"<br><br>
                    Constantes:<br><br>
                    •	Definición: Valores que no cambian durante la ejecución del programa. En Python, no hay una manera nativa de crear constantes, pero por convención se usan nombres en mayúsculas.<br><br>
                    
                    PI = 3.1416<br>
                    VELOCIDAD_DE_LUZ = 299792458  # en metros por segundo<br>
                    
                </p>
    
                <h2 class="tipos-contenido">tipos de dato</h2>
                <p class="parrafo-contenido">•	Numéricos: <br>
                    o	Enteros (int): Números sin parte decimal. Ejemplos: 10, -3, 0<br>
                    o	Flotantes (float): Números con parte decimal. Ejemplos: 3.14, -0.001<br>
                    o	Complejos (complex): Números con parte real e imaginaria. Ejemplos: 1+2j, 3-4j<br>
                    •	Texto (str): Secuencia de caracteres. Se pueden usar comillas simples o dobles. Ejemplos: "Hola", 'Mundo'<br>
                    •	Booleanos (bool): Valores lógicos. Solo pueden ser True o False. Ejemplos: True, False<br>
                    Ejemplos de Tipos de Datos:<br>
                    
                    entero = 10  # int<br>
                    flotante = 3.14  # float<br>
                    complejo = 1 + 2j  # complex<br>
                    cadena = "Hola Mundo"  # str<br>
                    booleano = True  # bool<br>
                    
                    
                </p>
    
                <h2 class="tipos-contenido">Condicionales</h2>
                <p class="parrafo-contenido">Definición: Permiten ejecutar código solo si se cumple una condición. <br><br>
                    Sintaxis:<br>
                    
                    if condicion:<br>
                        # código<br>
                    elif otra_condicion:<br>
                        # código<br>
                    else:<br>
                        # código<br><br>
                    Ejemplos:<br>
                    
                    edad = 18<br>
                    if edad >= 18:<br>
                        print("Eres mayor de edad")<br>
                    else:<br>
                        print("Eres menor de edad")<br><br>
                    Condiciones Anidadas:<br>
                    
                    numero = 15<br>
                    if numero > 10:<br>
                        if numero < 20:<br>
                            print("El número está entre 10 y 20")<br><br>
                    Uso de Operadores Lógicos:<br>
                    <br>
                    edad = 25<br>
                    if edad > 18 and edad < 30:<br>
                        print("Tienes entre 19 y 29 años")<br><br>
                    Comparación de Cadenas:<br>
                    
                    palabra = "Python"<br>
                    if palabra == "Python":<br>
                        print("La palabra es Python")<br>
                    
                    
                </p>
    
                <h2 class="tipos-contenido">Ciclos</h2>
                <p class="parrafo-contenido">Los ciclos en C++ permiten repetir un bloque de código múltiples veces. Esto es útil para realizar tareas repetitivas, como procesar elementos en un array o ejecutar una acción hasta que se cumpla una condición. <br> <br>
                    Tipos de Ciclos <br> <br>
                    •	Ciclo for: Se utiliza cuando el número de iteraciones es conocido de antemano. <br>

                    for (int i = 0; i < 5; ++i) { <br>
                        std::cout << "i = " << i << std::endl; <br>
                    } <br> <br>
                    •	Ciclo while: Se utiliza cuando el número de iteraciones no es conocido y depende de una condición. <br>
                    
                    int j = 0; <br>
                    while (j < 5) { <br>
                        std::cout << "j = " << j << std::endl; <br>
                        ++j; <br>
                    } <br> <br>
                    •	Ciclo do-while: Similar a while, pero garantiza que el bloque de código se ejecute al menos una vez. <br>
                    
                    int k = 0; <br>
                    do { <br>
                        std::cout << "k = " << k << std::endl; <br>
                        ++k; <br>
                    } while (k < 5); <br> <br>
                    
                    
                    
                    
                    int main() { <br>
                        // Ciclo for <br>
                        for (int i = 0; i < 5; ++i) { <br>
                            std::cout << "i = " << i << std::endl; <br>
                        } <br>
                    
                        // Ciclo while <br>
                        int j = 0; <br>
                        while (j < 5) { <br>
                            std::cout << "j = " << j << std::endl; <br>
                            ++j; <br>
                        } <br>
                    
                        // Ciclo do-while <br>
                        int k = 0; <br>
                        do { <br>
                            std::cout << "k = " << k << std::endl; <br>
                            ++k; <br>
                        } while (k < 5); <br>
                    
                        return 0; <br>
                    } <br>
                    
                </p>
    
                <h2 class="tipos-contenido">Funciones</h2>
                <p class="parrafo-contenido">Las funciones en C++ son bloques de código que realizan una tarea específica y pueden ser reutilizados en diferentes partes del programa. Esto permite la modularización del código y la mejora en la legibilidad y mantenimiento del mismo. <br> <br>
                    Definición y Declaración <br> <br>
                    •	Definición de Funciones: Define el tipo de retorno, el nombre y los parámetros de la función. <br>
                    
                    int sumar(int a, int b) { <br>
                        return a + b; <br>
                    } <br><br>
                    •	Declaración de Funciones: Anuncia la existencia de una función antes de su uso. <br>
                    
                    int sumar(int, int);<br><br>
                    •	Llamada a Funciones:<br>
                    
                    int resultado = sumar(5, 3);<br><br>
                    Ejemplo<br><br>
                    
                    
                    // Definición de la función<br>
                    int sumar(int a, int b) {<br>
                        return a + b;<br>
                    }<br>
                    
                    int main() {<br>
                        int resultado = sumar(5, 3);<br>
                        std::cout << "Resultado de la suma: " << resultado << std::endl;<br>
                        return 0;<br>
                    }<br>
                    
                </p>
    
                <h2 class="tipos-contenido">Estructuras de datos basicas</h2>
                <p class="parrafo-contenido">En C++, las estructuras de datos básicas permiten almacenar y organizar datos de manera eficiente. Estas estructuras son fundamentales para la manipulación y procesamiento de datos en programas complejos.<br><br>
                    Tipos Básicos<br><br>
                    •	Arrays: Colección de elementos del mismo tipo. La longitud es fija y se especifica en el momento de la declaración.<br>
                    
                    int numeros[5] = {1, 2, 3, 4, 5};<br>
                    •	Vectores (std::vector): Contenedores dinámicos que pueden cambiar su tamaño en tiempo de ejecución.<br>
                    
                    
                    
                    std::vector<int> numeros = {1, 2, 3, 4, 5}; <br><br>
                    •	Cadenas (std::string): Manipulación de cadenas de texto. Parte de la biblioteca estándar.<br> 
                    
                    #include <string>
                    
                    std::string saludo = "Hola, mundo!";<br><br>
                    •	Mapas (std::map): Colecciones de pares clave-valor que mantienen el orden de inserción.<br>

                    #include <map><br>
                    
                    std::map<std::string, int> edades;<br>
                    edades["Juan"] = 30;<br>
                    edades["Ana"] = 25;<br><br>
                    Ejemplo
                    <br><br>
                    
                    #include <vector><br>
                    #include <string><br>
                    
                    int main() {<br>
                        // Array<br>
                        int numeros[3] = {1, 2, 3};<br>
                        std::cout << "Primer número: " << numeros[0] << std::endl;<br>
                    
                        // Vector<br>
                        std::vector<std::string> nombres = {"Juan", "Ana", "Pedro"};<br>
                        std::cout << "Segundo nombre: " << nombres[1] << std::endl;<br>
                    
                        // Cadena<br>
                        std::string saludo = "Hola, C++";<br>
                        std::cout << saludo << std::endl;
                        <br>
                        return 0;<br>
                    }<br>
                    
                </p>
    
                <h2 class="tipos-contenido">programación orientada a objetos</h2>
                <p class="parrafo-contenido">La Programación Orientada a Objetos (POO) es un paradigma de programación que organiza el software en "objetos". Estos objetos representan entidades del mundo real y están compuestos por datos (atributos) y comportamientos (métodos). La POO promueve la reutilización del código, la modularidad y la facilidad de mantenimiento. En C++, la POO se implementa mediante clases y objetos, y permite la creación de sistemas más complejos y organizados.<br><br>
                    Clases y Objetos<br><br>
                    •	Clases: Las clases definen la estructura y el comportamiento de los objetos. Una clase es una plantilla para crear objetos, que pueden tener atributos (variables) y métodos (funciones).<br>
                    o	Definición de una Clase:<br>
                    
                    class Persona {<br>
                    public:<br>
                        std::string nombre;<br>
                        int edad;<br>
                    
                        void saludar() {<br>
                            std::cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << std::endl;<br>
                        }<br>
                    };<br><br>
                    o	Creación de Objetos:
                    <br>
                    int main() {<br>
                        Persona persona1;<br>
                        persona1.nombre = "Juan";<br>
                        persona1.edad = 30;<br>
                        persona1.saludar();  // Imprime "Hola, mi nombre es Juan y tengo 30 años."<br>
                        
                        return 0;<br>
                    }<br><br>
                    Herencia<br><br>
                    La herencia permite que una clase (la clase derivada) herede atributos y métodos de otra clase (la clase base). Esto ayuda a crear una jerarquía de clases y facilita la reutilización del código.<br>
                    •	Definición de Herencia:<br>
                    
                    class Animal {<br>
                    public:<br>
                        void comer() {<br>
                            std::cout << "El animal está comiendo." << std::endl;<br>
                        }<br>
                    };<br>
                    
                    class Perro : public Animal {<br>
                    public:<br>
                        void ladrar() {<br>
                            std::cout << "El perro está ladrando." << std::endl;<br>
                        }<br>
                    };<br><br>
                    •	Uso de la Clase Derivada:<br>
                    
                    int main() {<br>
                        Perro miPerro;<br>
                        miPerro.comer();  // Método heredado de Animal<br>
                        miPerro.ladrar(); // Método específico de Perro<br>
                        
                        return 0;<br>
                    }<br><br>
                    Polimorfismo<br><br>
                    El polimorfismo permite que diferentes clases respondan a la misma llamada de método de diferentes maneras. En C++, se logra mediante métodos virtuales y la sobreescritura de métodos.<br>
                    •	Métodos Virtuales:<br>
                    o	Se utiliza la palabra clave virtual en la clase base para indicar que un método puede ser sobreescrito en las clases derivadas.<br>
                    
                    class Animal {<br>
                    public:<br>
                        virtual void hacerSonido() {<br>
                            std::cout << "Sonido de animal." << std::endl;<br>
                        }<br>
                    };<br>
                    
                    class Perro : public Animal {<br>
                    public:<br>
                        void hacerSonido() override {<br>
                            std::cout << "Guau!" << std::endl;<br>
                        }<br>
                    };<br>
                    
                    class Gato : public Animal {<br>
                    public:<br>
                        void hacerSonido() override {<br>
                            std::cout << "Miau!" << std::endl;<br>
                        }<br>
                    };<br><br>
                    •	Uso del Polimorfismo:<br>
                    
                    int main() {<br>
                        Animal* animal;<br>
                        
                        Perro perro;<br>
                        Gato gato;<br>
                        
                        animal = &perro;<br>
                        animal->hacerSonido();  // Imprime "Guau!"<br>
                    
                        animal = &gato;<br>
                        animal->hacerSonido();  // Imprime "Miau!"<br>
                        
                        return 0;<br>
                    }<br><br>
                    Abstracción<br><br>
                    La abstracción oculta los detalles de implementación y muestra solo las características esenciales de un objeto. En C++, esto se logra mediante clases abstractas y métodos puros.<br>
                    •	Clases Abstractas:<br>
                    o	Son clases que no pueden ser instanciadas directamente y pueden tener métodos puros, que deben ser implementados por las clases derivadas.<br>
                    
                    class Forma {<br>
                    public:<br>
                        virtual void dibujar() = 0; // Método puro<br>
                    };<br>
                    
                    class Circulo : public Forma {<br>
                    public:<br>
                        void dibujar() override {<br>
                            std::cout << "Dibujando un círculo." << std::endl;<br>
                        }<br>
                    };<br><br>
                    •	Uso de Clases Abstractas:<br>
                    
                    int main() {<br>
                        Circulo miCirculo;<br>
                        miCirculo.dibujar();  // Imprime "Dibujando un círculo."<br>
                        
                        // Forma forma;  // Esto generaría un error de compilación porque Forma es una clase abstracta<br>
                    
                        return 0;<br>
                    }<br><br>
                    Encapsulación<br><br>
                    La encapsulación agrupa datos y métodos que operan sobre esos datos en una sola unidad o clase, y oculta la implementación interna. Esto asegura que los detalles internos de una clase no sean accesibles directamente desde fuera de la clase.<br>
                    •	Encapsulación en Clases:<br>
                    
                    
                    class CuentaBancaria {<br>
                    private:<br>
                        double saldo;<br>
                    
                    public:<br>
                        void depositar(double monto) {<br>
                            saldo += monto;<br>
                        }<br>
                    
                        void retirar(double monto) {<br>
                            if (monto <= saldo) {<br>
                                saldo -= monto;<br>
                            }<br>
                        }<br>
                    
                        double obtenerSaldo() const {<br>
                            return saldo;<br>
                        }<br>
                    };<br><br>
                    •	Uso de Encapsulación:<br>
                    
                    int main() {<br>
                        CuentaBancaria cuenta;<br>
                        cuenta.depositar(1000.0);<br>
                        cuenta.retirar(500.0);<br>
                        
                        std::cout << "Saldo actual: " << cuenta.obtenerSaldo() << std::endl; // Imprime "Saldo actual: 500.0"<br>
                        
                        return 0;<br>
                    }<br>
                    
                </p>
    
            </div>
        </main>
        

        
        
        <script src="./../../js/user/user.js"></script>
    </body>
</html>